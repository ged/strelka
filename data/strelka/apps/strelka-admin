#!/usr/bin/env ruby

require 'pp'
require 'pathname'
require 'strelka'
require 'uuidtools'


# The Strelka admin web console.
class Strelka::AdminConsole < Strelka::App

	# The 'appid' of the route to point the application at
	ID = Strelka::ADMINCONSOLE_ID

	# Load some plugins
	plugins :templating, :routing, :parameters, :negotiation

	# By default, responses are HTML
	default_type 'text/html'

	# Templating -- wrap everything in the layout
	layout 'layout.tmpl'
	templates \
		:console => 'admin/console.tmpl',
		:server  => 'admin/server.tmpl',
		:host    => 'admin/host.tmpl',
		:message => 'admin/message.tmpl'

	# Request parameter validation
	param :id,           :integer
	param :limit,        :integer
	param :offset,       :integer

	# Server parameter validations
	param :uuid,         /^[a-z][\-\w]+$/i
	param :access_log,   :printable
	param :error_log,    :printable
	param :chroot,       :printable
	param :pid_file,     :printable
	param :default_host, :hostname
	param :name,         :printable
	param :bind_addr,    :ip_address
	param :port,         :integer
	param :use_ssl,      :boolean

	untaint_all_constraints true


	### Initialize some application data.
	def initialize( * )

		# Use the templates in the same data directory as this app
		templatedir = Strelka::DATADIR + 'templates'
		Inversion::Template.configure( :template_paths => [templatedir] )

		# Commonalize all the loggers
		Mongrel2.logger = Strelka.logger
		Configurability.logger = Strelka.logger
		Inversion.logger.level = Logger::WARN

		@control = Mongrel2::Control.new( 'ipc://run/admin-control' )

		Mongrel2::Config.configure( :configdb => Strelka::DEFAULT_CONFIG_URI )

		super
	end


	# GET / -- console view
	get do |req|
		tmpl = self.template( :console )
		tmpl.request = req
		tmpl.control = @control
		tmpl.servers = Mongrel2::Config.servers

		return tmpl
	end


	#
	# Service API -- utility methods
	#

	# GET /uuid -- fetch a plain-text random UUID
	get '/uuid' do |req|
		res = req.response
		uuid = UUIDTools::UUID.random_create.to_s

		res.for( :text, :json, :yaml ) { uuid }
		res.for( :html ) do
			tmpl = self.template( :message )
			tmpl.message = uuid
			self.log.debug "Returning message template: %p" % [ tmpl ]
			tmpl
		end

		return res
	end


	#
	# Service API -- Servers
	#

	# GET /servers -- fetch a list of the configured Server objects.
	get '/servers' do |req|
		res = req.response
		servers = Mongrel2::Config::Server.dataset.naked

		# Make it into a REST-ish hash with links to each resource
		hash = servers.to_hash( :id )
		hash.each {|id,fields| fields[:uri] = "%s/server/%d" % [req.route, id] }

		res.for( :text ) do
			buf = ''
			PP.pp( hash, buf )
			buf
		end
		res.for( :json, :yaml ) { hash }

		return res
	end


	# GET /server/«uuid»
	get '/server/:id' do |req|
		self.log.debug "Fetching server record for %p" % [ req.params[:id] ]
		server = Mongrel2::Config::Server[ req.params[:id] ] or
			finish_with( HTTP::NOT_FOUND, "No such server" )

		res = req.response
		res.for( :html ) {
			tmpl = self.template( :server )
			tmpl.server = server
			tmpl.request = req
			tmpl.control = @control
			tmpl
		}
		res.for( :json, :yaml ) { server.values }

		return res
	end


	# Create a new server
	post '/server' do |req|
		finish_with( HTTP::BAD_REQUEST, req.params.error_messages.join(',') ) unless
			req.params.okay?

		begin
			server = Mongrel2::Config::Server.create( req.params.valid )
		rescue Sequel::ValidationFailed => err
			finish_with( HTTP::BAD_REQUEST, err.message )
		end

		server_uri = req.route + '/server/' + server.id
		res = req.response
		res.headers.location = server_uri

		res.for( :text ) do
			res.status = HTTP::CREATED
			"Server %s created: %s" % [ server.name, server_uri ]
		end
		res.for( :json, :yaml ) do
			res.status = HTTP::CREATED
			server_uri
		end

		return res
	end


	#
	# Service API -- Hosts
	#

	# GET /server/«uuid»/host/«id»
	get '/host/:id' do |req|
		id, uuid = req.params.values_at( :id, :uuid )
		self.log.debug "Fetching host record for host %d under the %p server" % [ id, uuid ]
		host = Mongrel2::Config::Host[ id ] or
			finish_with( HTTP::NOT_FOUND, "No such host" )

		res = req.response
		res.for( :html ) {
			tmpl = self.template( :host )
			tmpl.host = host
			tmpl.request = req
			tmpl.control = @control
			tmpl
		}
		res.for( :json, :yaml ) { host.values }

		return res
	end

end # class Strelka::AdminConsole


Strelka::AdminConsole.run if __FILE__ == $0

