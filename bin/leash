#!/usr/bin/env ruby

require 'configurability'
require 'configurability/config'

require 'mongrel2'
require 'mongrel2/config'
require 'strelka'

require 'pp'
require 'fileutils'
require 'shellwords'
require 'tnetstring'

require 'trollop'
require 'highline'

# Have to do it this way to avoid the vendored 'sysexits' under OSX.
gem 'sysexits'
require 'sysexits'


# A tool for setting up and controlling a Mongrel2 cluster.
class Strelka::LeashCommand
	extend ::Sysexits
	include Sysexits,
	        Strelka::Loggable,
	        Strelka::Constants

	# Make a HighLine color scheme
	COLOR_SCHEME = HighLine::ColorScheme.new do |scheme|
		scheme[:header]	   = [ :bold, :yellow ]
		scheme[:subheader] = [ :bold, :white ]
		scheme[:key]	   = [ :white ]
		scheme[:value]	   = [ :bold, :white ]
		scheme[:error]	   = [ :red ]
		scheme[:warning]   = [ :yellow ]
		scheme[:message]   = [ :reset ]
	end


	# Path to the default history file for 'shell' mode
	HISTORY_FILE = Pathname( "~/.leash.history" )

	# Number of items to store in history by default
	DEFAULT_HISTORY_SIZE = 100

	# The prompt the 'shell' mode should show
	PROMPT = 'leash> '


	# Class instance variables
	@command_help = Hash.new {|h,k| h[k] = { :desc => nil, :usage => ''} }
	@prompt = @option_parser = nil


	### Add a help string for the given +command+.
	def self::help( command, helpstring=nil )
		if helpstring
			@command_help[ command.to_sym ][:desc] = helpstring
		end

		return @command_help[ command.to_sym ][:desc]
	end


	### Add/fetch the +usagestring+ for +command+.
	def self::usage( command, usagestring=nil )
		if usagestring
			prefix = usagestring[ /\A(\s+)/, 1 ]
			usagestring.gsub!( /^#{prefix}/m, '' ) if prefix

			@command_help[ command.to_sym ][:usage] = usagestring
		end

		return @command_help[ command.to_sym ][:usage]
	end


	### Return the global Highline prompt object, creating it if necessary.
	def self::prompt
		unless @prompt
			@prompt = HighLine.new
			@prompt.wrap_at = @prompt.output_cols - 10
		end

		return @prompt
	end


	### Run the utility with the given +args+.
	def self::run( args )
		HighLine.color_scheme = COLOR_SCHEME

		oparser = self.make_option_parser
		opts = Trollop.with_standard_exception_handling( oparser ) do
			oparser.parse( args )
		end

		command = oparser.leftovers.shift
		self.new( opts ).run( command, *oparser.leftovers )
		exit :ok

	rescue => err
		Strelka.logger.fatal "Oops: %s: %s" % [ err.class.name, err.message ]
		Strelka.logger.debug { '  ' + err.backtrace.join("\n  ") }

		exit :software_error
	end


	### Return a String that describes the available commands, e.g., for the 'help'
	### command.
	def self::make_command_table
		commands = self.available_commands

		# Build the command table
		col1len = commands.map( &:length ).max
		return commands.collect do |cmd|
			helptext = self.help( cmd.to_sym ) or next # no help == invisible command
			"%s  %s" % [
				self.prompt.color(cmd.rjust(col1len), :key),
				self.prompt.color(helptext, :value)
			]
		end.compact
	end


	### Return an Array of the available commands.
	def self::available_commands
		return self.public_instance_methods( false ).
			map( &:to_s ).
			grep( /_command$/ ).
			map {|methodname| methodname.sub(/_command$/, '') }.
			sort
	end


	### Create and configure a command-line option parser for the command.
	### Returns a Trollop::Parser.
	def self::make_option_parser
		unless @option_parser
			progname = File.basename( $0 )
			default_configdb = Mongrel2::DEFAULT_CONFIG_URI

			# Make a list of the log level names and the available commands
			loglevels = Strelka::Logging::LOG_LEVELS.
				sort_by {|name,lvl| lvl }.
				collect {|name,lvl| name.to_s }.
				join( ', ' )
			command_table = self.make_command_table

			@option_parser = Trollop::Parser.new do
				banner "Take your Mongrel(2) for a walk:"

				text ''
				command_table.each {|line| text(line) }
				text ''

				text 'Global Options'
				opt :config, "Specify the Strelka config file to use.",
					:default => DEFAULT_ADMIN_CONFIG.to_s
				text ''

				text 'Other Options:'
				opt :debug, "Turn debugging on. Also sets the --loglevel to 'debug'."
				opt :loglevel, "Set the logging level. Must be one of: #{loglevels}",
					:default => Strelka::Logging::LOG_LEVEL_NAMES[ Strelka.logger.level ]
			end
		end

		return @option_parser
	end


	#################################################################
	###	I N S T A N C E   M E T H O D S
	#################################################################

	### Create a new instance of the command and set it up with the given
	### +options+.
	def initialize( options )
		Strelka.logger.formatter = Strelka::Logging::ColorFormatter.new( Strelka.logger )
		@options = options
		@shellmode = false

		if @options.debug
			$DEBUG = true
			$VERBOSE = true
			Strelka.logger.level = Logger::DEBUG
		elsif @options.loglevel
			Strelka.logger.level = Strelka::Logging::LOG_LEVELS[ @options.loglevel ]
		end

		Configurability.logger = Strelka.logger
		Mongrel2.logger = Strelka.logger

		Strelka.load_config( @options.config )
	end


	######
	public
	######

	# The Trollop options hash the command will read its configuration from
	attr_reader :options

	# True if running in shell mode
	attr_reader :shellmode


	# Delegate the instance #prompt method to the class method instead
	define_method( :prompt, &self.method(:prompt) )


	### Run the command with the specified +command+ and +args+.
	def run( command, *args )
		command ||= 'shell'
		cmd_method = nil

		begin
			cmd_method = self.method( "#{command}_command" )
		rescue NoMethodError => err
			error "No such command"
			exit :usage
		end

		cmd_method.call( *args )
	end


	#
	# Commands
	#

	### The 'help' command
	def help_command( *args )

		# Subcommand help
		if !args.empty?
			command = args.shift

			if self.class.available_commands.include?( command )
				header( self.class.help(command) )
				desc = "\n" + 'Usage: ' + command + ' ' + self.class.usage(command) + "\n"
				message( desc )
			else
				error "No such command %p" % [ command ]
			end

		# Help by itself show the table of available commands
		else
			command_table = self.class.make_command_table
			header "Available Commands"
			message( *command_table )
		end

		Configurability.logger = Strelka.logger
		Mongrel2.logger = Strelka.logger

		Strelka.load_config( @options.config )
	end
	help :help, "Show help for a single COMMAND if given, or list available commands if not"
	usage :help, "[COMMAND]"


	### The 'setup' command
	def setup_command( *args )
		self.setup_bootstrap_config
		self.setup_adminserver_directory

		if self.prompt.agree( "Start mongrel2 and the admin app? ", true )
			self.start_command
		else
			message "Okay, well stuff is now set up."
		end
	end
	help :setup, "Set up a new Strelka environment and start the admin server."


	### The 'start' command
	def start_command( *args )
		message "Starting..."

		m2pid = apppid = nil
		begin
			m2pid = self.start_admin_mongrel2
			apppid = self.start_admin_app

			adminserver = Mongrel2::Config::Server.by_uuid( ADMINSERVER_ID ) or
				raise "No server %p configured!" % [ ADMINSERVER_ID ]

			header "Okay, point a browser at http://%s:%d/" % [ adminserver.bind_addr, adminserver.port ]

		rescue => err
			error "%p while starting: %s: %s" % [ err.class, err.message, err.backtrace.first ]
			message "Killing admin mongrel2 at pid #{m2pid}..."
			Process.kill( :TERM, m2pid ) if m2pid

			message "Killing admin app at pid #{apppid}..."
			Process.kill( :TERM, apppid ) if apppid

		ensure
			pids = [ m2pid, apppid ]
			until pids.empty?
				pid, status = Process.wait2
				pids.delete( pid )

				if status.exited? || status.signaled?
					message "  child %d exited normally" % [ pid ]
				else
					message "  child %d exited abnormally" % [ pid ]
					unless pids.empty?
						message "    killing the other children"
						Process.kill( :TERM, *pids )
					end
				end
			end

			message "Done: %p" % [ results ]
		end
	end


	### The 'version' command
	def version_command( *args )
		message( "<%= color 'Version:', :header %> " + Mongrel2.version_string(true) )
	end
	help :version, "Prints the Ruby-Mongrel2 version."


	#
	# Utility methods
	#

	### Output normal output
	def message( *parts )
		self.prompt.say( parts.map(&:to_s).join($/) )
	end


	### Output the given +text+ highlighted as a header.
	def header( text )
		message( self.prompt.color(text, :header) )
	end


	### Output the given +text+ highlighted as an error.
	def error( text )
		message( self.prompt.color(text, :error) )
	end


	### Read command line history from HISTORY_FILE
	def read_history
		histfile = HISTORY_FILE.expand_path

		if histfile.exist?
			lines = histfile.readlines.collect {|line| line.chomp }
			self.log.debug "Read %d saved history commands from %s." % [ lines.length, histfile ]
			Readline::HISTORY.push( *lines )
		else
			self.log.debug "History file '%s' was empty or non-existant." % [ histfile ]
		end
	end


	### Save command line history to HISTORY_FILE
	def save_history
		histfile = HISTORY_FILE.expand_path

		lines = Readline::HISTORY.to_a.reverse.uniq.reverse
		lines = lines[ -DEFAULT_HISTORY_SIZE, DEFAULT_HISTORY_SIZE ] if
			lines.length > DEFAULT_HISTORY_SIZE

		self.log.debug "Saving %d history lines to %s." % [ lines.length, histfile ]

		histfile.open( File::WRONLY|File::CREAT|File::TRUNC ) do |ofh|
			ofh.puts( *lines )
		end
	end


	#
	# Mongrel2 functions
	#

	### Install a bootstrap config database for the admin server.
	def setup_bootstrap_config
		Mongrel2::Config.init_database

		if Mongrel2::Config::Server.by_uuid( ADMINSERVER_ID )
			message "Admin server is already configured"
			if !self.prompt.agree( "Replace the existing config? ", true )
				message "Okay, keeping the existing config."
				return
			end
		end

		configfile = DATADIR + 'bootstrap-config.rb'
		runspace = Module.new do
			extend Mongrel2::Config::DSL, FileUtils::Verbose
		end

		header "Installing admin server config from #{configfile}"
		source = configfile.read
		runspace.module_eval( source, configfile.to_s, 1 )
	end


	### Set up the mongrel2 chroot directory for Strelka's adminserver by copying static 
	### files, and creating the necessary directories. This depends on the configuration
	### being installed.
	def setup_adminserver_directory
		server = Mongrel2::Config::Server.by_uuid( ADMINSERVER_ID ) or
			raise "No server %p configured!" % [ ADMINSERVER_ID ]

		basedir = DATADIR
		header "Setting up chroot environment..."

		message "  creating directories..."
		directories = server.values.values_at( :access_log, :error_log, :pid_file ).collect do |path|
			path.slice!( 0, 1 ) if path.start_with?( '/' )
			file = basedir + path
			file.cleanpath.dirname
		end
		FileUtils.mkdir_p( directories, :verbose => $VERBOSE )
	end


	### Start the Mongrel2 instance that serves as the front end of the admin server.
	def start_admin_mongrel2
		server = Mongrel2::Config::Server.by_uuid( ADMINSERVER_ID ) or
			raise ScriptError, "Ack! No server named '#{ADMINSERVER_ID}' in #{Mongrel2::Config.pathname}"

		mongrel2 = ENV['MONGREL2'] || 'mongrel2'

		message "Starting mongrel2 (%s)..." % [ mongrel2 ]
		cmd = [ mongrel2, 'mongrel2 (Strelka Admin)' ]
		cfgpath = Mongrel2::Config.pathname.relative_path_from( DATADIR )

		Dir.chdir( DATADIR ) do
			return spawn( cmd, cfgpath.to_s, server.uuid )
		end
	end


	### Start the admin app.
	def start_admin_app
		message "Starting up control app..."

		pid = fork do
			$0 = Strelka::ADMINSERVER_ID
			strelka_admin = DATADIR + 'apps/strelka-admin'

			Kernel.load( strelka_admin )
			Strelka::AdminConsole.run

			exit!
		end

		return pid
	end


end # class Strelka::LeashCommand


Strelka::LeashCommand.run( ARGV.dup )

