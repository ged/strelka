---
title: Getting Started
layout: default
index: 2
filters:
  - erb
  - links
  - api
  - examples
  - textile
---

h2. <%= page.config['title'] %>

<div id="auto-toc"></div>

h3. Initial Mongrel2 Setup

We're going to assume you've already built and installed the Mongrel2 daemon.  If not, please refer to the "Mongrel2 documentation":http://mongrel2.org/wiki/quick_start.html and get that ready.  You can create the Mongrel2 configuration in any fashion you please, but the Mongrel2 ruby module includes a nice DSL for doing so.  Here's the configuration script we'll be using for the entirety of the Strelka examples.

<?example { lang: Ruby, caption: "Mongrel2 config DSL script" } ?>
# m2config.rb

# Set up logs and runtime state directory for Mongrel2. The functions from
# FileUtils are added to the DSL's namespace by the m2sh.rb tool.
mkdir_p 'run'
mkdir_p 'logs'

server 'strelka-tester' do
	chroot '.'
	default_host 'localhost'
	name 'localhost'
	port '8080'

	host 'localhost' do
		route '/', handler( 'tcp://127.0.0.1:9999', 'helloworldapp' )
	end
end
<?end example ?>

You can load the above into a Mongrel2 SQLite database using the @m2sh.rb@ tool: 

<?example { lang: Ruby, caption: "Create the Mongrel2 Configuration" } ?>
$ m2sh.rb -c mongrel2.sqlite load m2config.rb
<?end example ?>

The above will generate a configuration database for use with Mongrel2 in your current working directory, with the default required directory structure.  Mongrel2 will listen on port 8080, and send all requests (starting at the root URI @/@) to a handler called @helloworldapp@.

You can start Mongrel2 in a variety of ways.  To start it using the @m2sh.rb@ utility, with our newly created example configuration, just run @$ m2sh.rb -c mongrel2.sqlite start strelka-tester@ at the command line.

Now that the Mongrel2 daemon is up and running, we can move forward and create our first application!


h3. A Minimal Application

Strelka applications are subclasses of the <?api Strelka::App ?> class. Strelka::App is pretty minimal by itself; it inherits most of its behavior from the basic Mongrel2::Handler class, only adding a few convenience methods for common HTTP tasks.

A minimal application would look something like:

<?example { lang: Ruby, caption: "A dead-simple app." } ?>
#!/usr/bin/env ruby

require 'strelka'

class HelloWorldApp < Strelka::App

	def handle_request( request )
		response = request.response
		response.content_type = 'text/plain'
		response.puts( "Hello, World!" )
		return response
	end

end # class HelloWorldApp

# Run the app
Strelka.load_config( 'config.yaml' )
HelloWorldApp.run if __FILE__ == $0
<?end example ?>

While functional, this application is pretty dumb, and making it do anything more intelligent on your own would require a bunch of additional code and accompanying tests.  Fortunately, Strelka already has done the heavy lifting. It knows how to read the Mongrel2 configuration and hook your app up with the right sockets to talk to the Mongrel2 front end (providing you follow one of several simple conventions), provides hooks into the lifecycle of an HTTP request, and includes a plugin system that uses these hooks to handle common application tasks. This allows you to mix in the specific framework parts you need, so you get exactly what you want and nothing more.

h3. Talking to Mongrel2

Mongrel2 associates handlers with itself via an identifier, which is described in the Mongrel2 manual as a UUID, but can actually be any string consisting of dashes and alphanumeric characters. Strelka reads the Mongrel2 config database, and can automatically configure its apps to talk to the right socket with the right @send_ident@ if it can find them. Its gives you a couple of different ways of doing this. It will default to a string derived from the name of the class, or you can set it yourself by declaring an @ID@ constant in your application class. If you need more control, you can also override the @::run@ class method and @super@ with the right @appid@:

<?example { language: ruby, caption: "Overriding the ::run method" } ?>
class HelloWorldApp
	# Run as a tester if not running in the production environment
	def self::run
		appid = if Socket.gethostname.include?( 'test' )
				'helloworld-test'
			else
				'helloworld'
			end

		super( appid )
	end
end
<?end ?>

Because our @config.sqlite@ configuration directs requests to @/@ to be sent to the @helloworldapp@ handler, Strelka will automatically find and pair this route to Mongrel2 when run.

Run this handler, then point a browser to @http://localhost:8080/@.  If you see the text "Hello, World!", congrats!  We'll build off of this in the next section, the <?link "tutorial":Strelka Tutorial ?>.

