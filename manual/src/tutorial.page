---
title: Strelka Tutorial
layout: default
index: 3
filters:
  - erb
  - api
  - links
  - examples
  - textile
---

h2. <%= page.config['title'] %>

<div id="auto-toc"></div>

h3. Working With Plugins

As mentioned on the <?link Getting Started ?> page, our default application doesn't afford us many conveniences over using a raw @Mongrel2::Handler@.  Strelka breaks most of its niceties into a plugin system, so you can add only what you require, keeping your apps nice and streamlined.

The plugins system is contained in the <?api Strelka::App::Plugins ?> mixin, which is included in <?api Strelka::App ?> already. This adds the @plugins@ declarative, which you use from your app to load the plugins you want to use.

If you're interested in hooking into the HTTP conversation yourself, or just want to factor your common application code up to a reusable plugin, you can <?link Write Your Own Strelka Plugin ?>, too.


h3. Sinatra-like Routing

Rather than checking the @request.path@ and supplying elaborate conditional dispatching yourself, you can use the +routing+ plugin.  This provides block style route declarations to your application, that execute their blocks when a matching HTTP method and path URI is requested.  This is similar to "Sinatra's":http://www.sinatrarb.com/ routing -- if you've used that before, this should be familiar territory. It matches routes a bit differently, though. Instead of top down, first match wins, Strelka's routing is more similar to the routing algorithm that Mongrel2 uses. The longest, most-specific route wins, regardless of where it was defined.

<?example { lang: Ruby, caption: "Using the Routing Plugin" } ?>
class HelloWorldApp < Strelka::App

	plugins :routing

    # match any GET request
	get do |req|
		req.response.content_type = 'text/plain'
		req.response << 'Hello, World!'
		return req.response
	end

	# match a GET request starting with '/goodbye'
	get '/goodbye' do |req|
		req.response.content_type = 'text/plain'
		req.response << "Goodbye, cruel World!"
		return req.response
	end
end
<?end example ?>

The example app above responds only to 'GET' requests.  Anything under the @/goodbye@ URI responds with a departure message, while any other request (anywhere in the URI space!) responds with a friendly greeting.  You can think of this almost as wildcard routing, effectively dividing up the URI space into individual handler blocks.  A lack of a URI argument is the same thing as declaring one with @/@.

This introduces some important concepts, as well.   All blocks are passed the <?api Strelka::HTTPRequest ?> object and should return a <?api Strelka::HTTPResponse ?> object. Both the request and response are wrappers around _streams_ (input and output, respectively), similar to STDIN and STDOUT in a command-line utility. These streams contain the *body* of the request and response, and can be any @IO@-like object.


h3. More Explicit Routing

Sometimes you might have an explicit URI mapping already in mind, or just don't want the same HTTP resource potentially accessible under different URLs.  The +routing+ plugin has an option to alter its default matching behavior, and make it only match routes that are requested specifically.

<?example { lang: Ruby, caption: "Exclusive Routing" } ?>
class HelloWorldApp < Strelka::App

	plugins :routing

	# Require exact matching for route paths
	router :exclusive

    # only match a GET request to '/'
	get do |req|
		req.response.content_type = 'text/plain'
		req.response << 'Hello, World!'
		return req.response
	end

	# only match a GET request for '/goodbye'
	get '/goodbye' do |req|
		req.response.content_type = 'text/plain'
		req.response << "Goodbye, cruel World!"
		return req.response
	end
end
<?end example ?>

This application now serves requests to only @/@ and @/goodbye@.  Anything else is met with a @404 NOT FOUND@ response.


h3. Setting Content-Types

You can, of course, explicitly set the content type for each route as we've been doing above.  If you'd like to have a fallback if one isn't set, Strelka provides an easy way to do so.

<?example { lang: Ruby, caption: "A default Content-Type" } ?>
class HelloWorldApp < Strelka::App

	plugins :routing

	# Unless explicitly stated, use a text/plain content-type.
	default_type 'text/plain'

	get do |req|
		req.response << 'Hello, World!'
		return req.response
	end

	get '/goodbye' do |req|
		req.response << "Goodbye, cruel World!"
		return req.response
	end
end
<?end example ?>

Now all content sent will have a @text/plain@ content-type, unless specifically set to something else in the response.


h3. Dealing with URI and Query Parameters

If you just want to retrieve passed query parameters directly, they are accessible as a Hash via the @Request@ object.

<?example { lang: Ruby, caption: "Getting the Query Parameters" } ?>
class HelloWorldApp < Strelka::App

	plugins :routing

	default_type 'text/plain'

	get '/' do |req|
		name = req.params['name'] || 'Handsome'
		req.response << "Hello, #{name}!"
		return req.response
	end
end
<?end example ?>

Try passing @/?name=there@ to the handler.  By default, no validity-checking is done; it'll just return the query arguments as Strelka saw them.

Strelka offers a +parameters+ plugin that provides a framework for describing parameters globally.  It manages validation and untainting, and you can override the global descriptions on a per-route basis.

<?example { lang: Ruby, caption: "Using the 'parameters' Plugin" } ?>
class HelloWorldApp < Strelka::App

	plugins :routing, :parameters

	default_type 'text/plain'

	param :name, /[[:alpha:]]+/

	get '/' do |req|
		name = req.params['name'] || 'Handsome'
		req.response << "Hello, #{name}!"
		return req.response
	end
end
<?end example ?>

Loading the plugin gives you the +param+ method, which you use to declare all of the global parameters your application might use.  It already has a bunch of built in matchers for common things like email and hostnames.  You can continue using the @params@ attribute as a Hash, but it now is much smarter than it was before.

<?example { lang: Ruby, caption: "Using the 'parameters' Plugin" } ?>
class HelloWorldApp < Strelka::App

	plugins :routing, :parameters

	default_type 'text/plain'

	param :name, :alpha, :required
	param :email, 'An RFC822 email address'

	get '/' do |req|
		response = req.response

		response.puts( req.params.inspect )

		if req.params.okay?
			response << "Hello, %s!\n" % [ req.params['name'] ]
		else
			response << "Aaahhhh noooaaahhhh!!\n"
			req.params.error_messages.each do |err|
				response.body << " - %s\n" % [ err ]
			end
		end

		return response
	end
end
<?end example ?>

Passing the URL @/?name=Bob@ should output the following:

<pre>
1 parameters (1 valid, 0 invalid, 0 missing)
Hello, Bob!
</pre>

While passing @/?email=what@ should display:

<pre>
1 parameters (0 valid, 1 invalid, 1 missing)
Aaahhhh noooaaahhhh!!
 - Missing value for 'Name'
 - Invalid value for 'An RFC822 email address'
</pre>

Neat.

All this time, we've only been dealing with query parameters.  Using the +parameters+ plugin also allows params to be part of the route path itself.  If you have both query AND route parameters in a request, the route values win.

<?example { lang: Ruby, caption: "Route Parameters" } ?>
class HelloWorldApp < Strelka::App

	plugins :routing, :parameters

	default_type 'text/plain'

	param :name, :alpha
	param :email, 'An RFC822 email address'

	get '/' do |req|
		req.params.override( :email, /\w+@\w+/ )
		name = req.params['name'] || 'Handsome'
		req.response << "Hello, %s!" % [ name ]
		return req.response
	end

	get '/:name' do |req|
		response = req.response

		if req.params.okay?
			response.puts "Name: %s" % [ req.params['name'] ]
		else
			response.status = HTTP::BAD_REQUEST
			response.puts( *req.params.error_messages )
		end

		return response
	end
end
<?end example ?>

The above example shows how to selectively override the @email@ parameter for the @/@ route, and how to incorporate a parameter into a route.  There are many, many more options for the param object.  Please see the <?api "Strelka API documentation":Strelka::ParamValidator ?> for more information.

To document:

* Named match groups
* Validating uploaded files (mediatype, size, etc.)
* Validating non-form entity bodies (YAML, JSON, etc.)


h3. Accessing Headers

The request and response objects both have a headers object that provides methods for getting and setting header values. You can use it like a Hash:

<?example { lang: Ruby, caption: "Accessing headers like a Hash." } ?>
remote_host = request.header['X-Forwarded-For']
response.header['Content-Type'] = 'image/jpeg'
<?end example ?>

or with a Symbol key (hyphens become underscores):

<?example { lang: Ruby, caption: "Accessing headers like a Hash with Symbol keys." } ?>
remote_host = request.header[:x_forwarded_for]
response.header[:content_type] = 'application/pdf'
<?end example ?>

You can also access it using struct-like methods, with the same pattern as with Symbol keys:

<?example { lang: Ruby, caption: "Accessing headers like a Struct." } ?>
remote_host = request.header.x_forwarded_for
response.header.content_type = 'text/html'
<?end example ?>

Keep in mind that some headers can appear multiple times, so what you get back could be an Array, too.


h3. Setting Response Status

Responses start out with a @204 No Content@ status, and will automatically switch to @200 OK@ if you add a body to it.

You can, of course, set the status yourself:

<?example { lang: Ruby, caption: "Setting the response status directly." } ?>
response.status = HTTP::NOT_FOUND
<?end example ?>

If you set it directly, however, the response will still go back through all of your loaded plugins, which is probably not what you want. In that case you can finish a request early using the 
<?api "finish_with helper":Strelka::App#finish_with ?>:

<?example { lang: Ruby, caption: "Finishing a response immediately." } ?>
finish_with HTTP::NOT_FOUND, "That user doesn't exist."
<?end example ?>

Using @finish_with@ stops additional processing immediately and returns a response with the specified status and message. You can also include additional headers:

<?example { lang: Ruby, caption: "Finishing a response immediately with custom headers." } ?>
new_location = "http://example.com/somewhere/else"
finish_with HTTP::REDIRECT,
	"That resource has moved here: #{new_location}.",
	headers: { location: new_location }
<?end example ?>


h3. Using Templates

Most web frameworks come with some kind of templating built in, but Strelka doesn't have any preconceived assumptions about what you might want to use for your applications. As long as your templates implement @#to_s@, you can set them as the response body and your app will work fine:

<?example { lang: Ruby, caption: "Using Erubis templates." } ?>
require 'erubis'

class HelloWorldApp < Strelka::App

	plugins :routing

	default_type 'text/html'

	get '/' do |req|
		res = req.response
		template = Erubis::Eruby.load_file( 'template1.rhtml' )
		res.body = template.evaluate( :greeting => "Why hello!" )
		return res
	end

end
<?end example ?>

Strelka comes with a @:templating@ plugin that provides your application with the ability to use the "Inversion templating system":http://deveiate.org/code/Inversion-manual/ to build the response body.



	- return template symbol
	- return response with a template body
	- just return the template
	- the layout template
	- what variables templates have default access to (request, route)

h3. Filtering Every Request and/or Response

h3. Altering Error Display

h3. Sessions

h3. Authentication and Authorization

h3. HTTP Content Negotiation

h3. REST Services

